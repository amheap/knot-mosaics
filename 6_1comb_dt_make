#!/opt/anaconda3/bin/python
import numpy as np
import fileinput
import math
from itertools import product

n = 10
split1 = 5
split2 = n - split1
minCrossings = 9
arr1 = np.array([x for x in product([7, 8, 9, 10], repeat=split1)])
arr2 = np.array([x for x in product([7, 8, 9, 10], repeat=split2)])

fshell = np.array([[ 0,  2,  1,  0,  0,  0],
 [ 2, -1, -1,  1,  0,  0],
 [ 3, -1, -1, -1,  1,  0],
 [ 0,  3, -1, -1, -1,  1],
 [ 0,  0,  3, -1, -1,  4],
 [ 0,  0,  0,  3,  4,  0]])
def shellfill( shell , vector):
    newShell = shell.copy()
    newShell[newShell == -1] = vector
    return newShell


### This function finds the first 2 in the knot
def firsti(M):
    i = -1
    val = 0
    while val == 0:
        i += 1
        val = M.item(i)
    a = i // len(M)
    b = i % len(M)
    return [a, b]

def dowker2(M):
    ''' Returns the dt notation of a knot mosaic matrix
     :param M - a square numpy array representing a knot mosaic

     :returns finalDT - a list of the dt notation (only even numbers)
    '''
    ## We need to initialize some things to start at the 2 and follow the knot from there
    ## These 5 take care of the walking
    starti = firsti(M)[0]
    startj = firsti(M)[1]
    lastcell = [starti, startj]
    currenti = starti
    currentj = startj + 1
    ## These three take care of the output
    pairs = []
    length = len(M)
    i = 1
    path = [2]
    ## this will take care of links
    tilesvisit = 1
    crosstiles = np.count_nonzero(M==7) + np.count_nonzero(M==8) + np.count_nonzero(M==9) + np.count_nonzero(M==10)
    linknumber = np.count_nonzero(M) + crosstiles
    ## Nothing interesting happens until 9 & 10
    while [currenti, currentj] != [starti, startj]:
        #if len(path) > length:
        #    return 'link'
        tilesvisit += 1
        path.append(M[currenti, currentj])
        if M[currenti, currentj] == 1 and lastcell == [currenti, currentj - 1]:
            lastcell = [currenti, currentj]
            currenti += 1
        elif M[currenti, currentj] == 1 and lastcell == [currenti + 1, currentj]:
            lastcell = [currenti, currentj]
            currentj += -1
        elif M[currenti, currentj] == 2 and lastcell == [currenti + 1, currentj]:
            lastcell = [currenti, currentj]
            currentj += 1
        elif M[currenti, currentj] == 2 and lastcell == [currenti, currentj + 1]:
            lastcell = [currenti, currentj]
            currenti += 1
        elif M[currenti, currentj] == 3 and lastcell == [currenti, currentj + 1]:
            lastcell = [currenti, currentj]
            currenti += -1
        elif M[currenti, currentj] == 3 and lastcell == [currenti - 1, currentj]:
            lastcell = [currenti, currentj]
            currentj += 1
        elif M[currenti, currentj] == 4 and lastcell == [currenti - 1, currentj]:
            lastcell = [currenti, currentj]
            currentj += -1
        elif M[currenti, currentj] == 4 and lastcell == [currenti, currentj - 1]:
            lastcell = [currenti, currentj]
            currenti += - 1
        elif M[currenti, currentj] == 5 and lastcell == [currenti, currentj - 1]:
            lastcell = [currenti, currentj]
            currentj += 1
        elif M[currenti, currentj] == 5 and lastcell == [currenti, currentj + 1]:
            lastcell = [currenti, currentj]
            currentj += -1
        elif M[currenti, currentj] == 6 and lastcell == [currenti + 1, currentj]:
            lastcell = [currenti, currentj]
            currenti += -1
        elif M[currenti, currentj] == 6 and lastcell == [currenti - 1, currentj]:
            lastcell = [currenti, currentj]
            currenti += 1
        elif M[currenti, currentj] == 7 and lastcell == [currenti + 1, currentj]:
            lastcell = [currenti, currentj]
            currentj += -1
        elif M[currenti, currentj] == 7 and lastcell == [currenti - 1, currentj]:
            lastcell = [currenti, currentj]
            currentj += 1
        elif M[currenti, currentj] == 7 and lastcell == [currenti, currentj + 1]:
            lastcell = [currenti, currentj]
            currenti += -1
        elif M[currenti, currentj] == 7 and lastcell == [currenti, currentj - 1]:
            lastcell = [currenti, currentj]
            currenti += 1
        elif M[currenti, currentj] == 8 and lastcell == [currenti + 1, currentj]:
            lastcell = [currenti, currentj]
            currentj += 1
        elif M[currenti, currentj] == 8 and lastcell == [currenti - 1, currentj]:
            lastcell = [currenti, currentj]
            currentj += -1
        elif M[currenti, currentj] == 8 and lastcell == [currenti, currentj + 1]:
            lastcell = [currenti, currentj]
            currenti += 1
        elif M[currenti, currentj] == 8 and lastcell == [currenti, currentj - 1]:
            lastcell = [currenti, currentj]
            currenti += -1

        ## Here, we need to find which are overcrossings and undercrossings. That's
        ## not too hard. Then, when we hit one of these crossing tiles, we want to take
        ## whatever number we are on, record it, and record the index of where we found
        ## it. Then, later we can match each entry with the same index, and then just take the
        ## tuple of numbers and string them together for our actual DT notation.
        elif M[currenti, currentj] == 9 and lastcell == [currenti, currentj - 1]:
            pairs.append((currenti * length + currentj, i))
            i += 1
            lastcell = [currenti, currentj]
            currentj += 1
        elif M[currenti, currentj] == 9 and lastcell == [currenti, currentj + 1]:
            pairs.append((currenti * length + currentj, i))
            i += 1
            lastcell = [currenti, currentj]
            currentj += -1
        elif M[currenti, currentj] == 9 and lastcell == [currenti + 1, currentj]:
            if i % 2 == 0:
                pairs.append((currenti * length + currentj, -i))
            else:
                pairs.append((currenti * length + currentj, i))
            i += 1
            lastcell = [currenti, currentj]
            currenti += -1
        elif M[currenti, currentj] == 9 and lastcell == [currenti - 1, currentj]:
            if i % 2 == 0:
                pairs.append((currenti * length + currentj, -i))
            else:
                pairs.append((currenti * length + currentj, i))
            i += 1
            lastcell = [currenti, currentj]
            currenti += 1
        elif M[currenti, currentj] == 10 and lastcell == [currenti, currentj - 1]:
            if i % 2 == 0:
                pairs.append((currenti * length + currentj, -i))
            else:
                pairs.append((currenti * length + currentj, i))
            i += 1
            lastcell = [currenti, currentj]
            currentj += 1
        elif M[currenti, currentj] == 10 and lastcell == [currenti, currentj + 1]:
            if i % 2 == 0:
                pairs.append((currenti * length + currentj, -i))
            else:
                pairs.append((currenti * length + currentj, i))
            i += 1
            lastcell = [currenti, currentj]
            currentj += -1
        elif M[currenti, currentj] == 10 and lastcell == [currenti + 1, currentj]:
            pairs.append((currenti * length + currentj, i))
            i += 1
            lastcell = [currenti, currentj]
            currenti += -1
        elif M[currenti, currentj] == 10 and lastcell == [currenti - 1, currentj]:
            pairs.append((currenti * length + currentj, i))
            i += 1
            lastcell = [currenti, currentj]
            currenti += 1

    # This part converts pairs to only the even numbers of the Dowker Notation, 
    # in the correct order
    pairs = np.array(pairs)
    evens = pairs[1::2]
    odds = pairs[::2]
    finalDT = [len(odds), 0]
    crossn = np.count_nonzero(M==9) + np.count_nonzero(M==10)
    if tilesvisit != linknumber:
        finalDT = 'link'
    else:
        for i in range(len(odds)):
            finalDT.append(evens[evens[:,0] == odds[:,0][i]][0][1])
        return finalDT


def make_dts(a1, a2, min_crossings):
    a1_reduced = a1.copy()
    a1_reduced[a1_reduced < 9] = 0
    a1_reduced[a1_reduced >= 9] = 1
    a1_sum = np.sum(a1_reduced, 1)

    a2_reduced = a2.copy()
    a2_reduced[a2_reduced < 9] = 0
    a2_reduced[a2_reduced >= 9] = 1
    a2_sum = np.sum(a2_reduced, 1)

    #A = np.zeros([100000, n])
    #count = 0
    for i in range(min_crossings - len(a2[0]), np.max(a1_sum) + 1):
        mask1 = a1_sum == i
        for j in range(minCrossings - i, len(a2[0]) + 1):
            mask2 = a2_sum == j
            for line1 in a1[mask1]:
                for line2 in a2[mask2]:
                    v = ([int(x) for x in np.concatenate((line1, line2))])
                    ogVector = str(v).replace(' ', '')
                    m = shellfill(fshell, v)
                    dt = dowker2(m)
                    if dt == None:
                        continue
                    

                    
                    print(str(dt).replace(',', '')[1:-1]+";"+ogVector.rstrip())



make_dts(arr1, arr2, minCrossings)

## Basically, this program has two parts: the big block of text that's the 'ifelse'
## statements which "walk" along the knot, and the added comments in the 9 & 10 cases
## which output the actual dawker notation.

## The output of this function as it stands is a list of tuples whose first entries are
## the index where each 9 & 10 lives, and secondly where
